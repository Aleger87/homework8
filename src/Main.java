import java.time.LocalDate;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        System.out.println("Задание 1");
        task1();
        System.out.println("Задание 2");
        task2();
        System.out.println("Задание 3");
        task3();
        System.out.println("Задание 4");
        task4();
        System.out.println("Задание 5");
        task5();
        System.out.println("Задание 6");
        task6();
    }


    /*1
    Реализуйте метод, который получает в качестве параметра год, а затем проверяет, является ли он високосным, и выводит результат в консоль.
    Эту проверку вы уже реализовывали в задании по условным операторам.
    Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
    Результат программы выведите в консоль. Если год високосный,
     то должно быть выведено “*номер года —* високосный год”.
    Если год не високосный, то, соответственно: “*номер года —* не **високосный год”.
    Подсказку с выполнением задания вы можете найти в шпаргалке урока.*
     */

    private static void task1(){
        printLeapYear(2000);
    }
    private static void printLeapYear( int year){
        if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
            System.out.println(year +" високосный год");
        } else {
            System.out.println(year +" невисокосный год");
        }
    }

    /*2
     Вспомним задание 2 по условным операторам, где нам необходимо было предложить пользователю облегченную версию приложения.
    - Текст прошлого задания
        К нам пришли коллеги и сообщили, что нам нужно знать не только операционную систему телефона, но и год его создания: от этого зависит,
        подойдет ли приложение для телефона или оно просто не установится.
        Если телефон произведен с 2015 по нынешний год, то приложение будет работать корректно.
        Если телефон произведен ранее 2015 года, то клиенту нужно посоветовать установить облегченную версию приложения.
        Ваша задача: написать программу, которая выдает соответствующее сообщение клиенту при наличии двух условий —
        операционной системы телефона (iOS или Android) и года производства.
        Если год выпуска ранее 2015 года, то к сообщению об установке нужно добавить информацию об облегченной версии.
        Например, для iOS оно будет звучать так:
        «Установите облегченную версию приложения для iOS по ссылке».
        А для Android так:
        «Установите облегченную версию приложения для Android по ссылке».
        При этом для пользователей с телефоном с 2015 года выпуска нужно вывести обычное предложение об установке приложения.
        Для обозначения года создания используйте переменную clientDeviceYear, где необходимо указать 2015 год.
        **Важно**: вложенность больше двух этажей не допускается (условный оператор внутри условного оператора).
    Напишите метод, куда подаются два параметра: тип операционной системы (ОС) ( 0 — iOS или 1 — Android) и год выпуска устройства.
    Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
    Текущий год можно получить таким способом:
    ```java
    int currentYear = LocalDate.now().getYear();
    ```
    Или самим задать значение вручную, введя в переменную числовое значение.
    В результате программа должна выводить в консоль в зависимости от исходных данных,
    какую версию приложения (обычную или lite) и для какой ОС (Android или iOS) нужно установить пользователю.
    * */

    //int currentYear = LocalDate.now().getYear();

    private static void task2 () {
        int clientDeviceYear = 2015;
        byte clientOS = 1;
        printTypeOs(clientDeviceYear, clientOS);

    }

    private static void printTypeOs (int year, byte os){
        int currentYear = LocalDate.now().getYear();
        if (year < currentYear && os == 0) {
            System.out.println("Установите облегченную версию приложения для iOS по ссылке");
        } else if (year < currentYear && os == 1) {
            System.out.println("Установите облегченную версию приложения для Android по ссылке");
        } else {
            System.out.println("Приложение установлено");
        }
    }

    /*3
    Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
    - Текст прошлого задания
    Вернемся к делам банковским. У нас хороший банк, поэтому для наших клиентов мы организуем доставку банковских карт на дом с четкой датой доставки.
    Чтобы известить клиента о том, когда будет доставлена его карта, нам нужно знать расстояние от нашего офиса до адреса доставки.
    Правила доставки такие:
    Доставка в пределах 20 км занимает сутки.
    Доставка в пределах от 20 км до 60 км добавляет еще один день доставки.
    Доставка в пределах 60 км до 100 км добавляет еще одни сутки.
    То есть с каждым следующим интервалом доставки срок увеличивается на 1 день.
    Напишите программу, которая выдает сообщение в консоль:
    "Потребуется дней: " + срок доставки
    Объявите целочисленную переменную deliveryDistance = 95, которая содержит дистанцию до клиента
    Наша задача — доработать код, а именно написать метод, который на вход принимает дистанцию и возвращает итоговое количество дней доставки.
    * */

    private static void task3() {
        int deliveryDistance = 101;
        if (checkDeliveryDistance(deliveryDistance)){
            System.out.println("Заберите карту в ближайшем отделении банка");
            return;
        }
        int day = speedDelivery(deliveryDistance);
        System.out.println("Потребуется дней: "+ day);
    }

    private static int  speedDelivery (int deliveryDistance){
        int day =1;
        if (deliveryDistance > 20 && deliveryDistance <= 60){
            day += 1;
        }else if (deliveryDistance > 60 && deliveryDistance <= 100){
            day += 2;
        }
        return day;
    }

    private static boolean checkDeliveryDistance(int distance){
        boolean ok;
        if (distance > 100) {
            return true;
        }
        return false;
    }

    /*4
    Напишите метод, который получает на вход массив и переставляет все его элементы в обратном порядке.
    Подобное задание вы решали в домашнем задании по массивам.
    - Текст прошлого задания
        Отойдем от подсчетов.
        В нашей бухгалтерской книге появился баг. Что-то пошло нет так, и Ф.И.О. сотрудников начали отображаться в обратную сторону. Т. е.
        вместо «Иванов Иван Иванович» мы имеем «чивонавИ навИ вонавИ».
        Данные с именами сотрудников хранятся в виде массива символов (char[]).
        Напишите код, который в случае такого бага будет выводить Ф. И. О. сотрудников в корректном виде. В качестве данных для массива используйте:
        char[] reverseFullName = { 'n', 'a', 'v', 'I', ' ', 'v', 'o', 'n', 'a', 'v', 'I'};
        В результате в консоль должно быть выведено "Ivanov Ivan".
        **Важно**: не используйте дополнительные массивы для решения этой задачи. Необходимо корректно пройти по массиву циклом и
        распечатать его элементы в правильном порядке
    В метод приходит массив, допустим:
    {3, 2, 1, 6, 5}.
    Нужно без вспомогательного массива переместить элементы так, чтобы поданный массив стал: {5, 6, 1, 2, 3}.
    Рекомендуем написать этот метод без возвращаемого значения. Вы будете приятно удивлены, что даже если мы не вернем массив,
    первоначальный массив изменится, когда мы будем модернизировать пришедший в виде параметра массив внутри метода.
    Причину такого поведения ссылочных типов (объектов) вы узнаете на следующем уроке или на QA-вебинаре.
    * */

    private static void task4 (){
        Object[] reverseFullName = { 'n', 'a', 'v', 'I', ' ', 'v', 'o', 'n', 'a', 'v', 'I'};
        nameCorrect(reverseFullName);
        System.out.println();
        Object[] data = {3, 2, 1, 6, 5};
        nameCorrect(data);
        System.out.println();
        arrayReplace(data);
        arrayReplace(reverseFullName);
    }

    private static void nameCorrect (Object[] arr) {
        for (int i = arr.length - 1; i >= 0; i--) {
            System.out.print(arr[i]);
        }
    }

    private static void arrayReplace (Object[] arr){
        int j = arr.length-1;
        for (int i = 0; i < arr.length/2; i++) {
            Object t = arr[i];
            arr[i] = arr[j-i];
            arr[j-i] = t;
        }
        System.out.println(Arrays.toString(arr));
    }

    /*
    Вернемся к задаче о валидаторе текста из урока по строкам.
        - Условие задачи из урока 1.7
            Повышенная сложность. Задание 8
            Дана строка из букв английского алфавита "aabccddefgghiijjkk".
            Нужно найти и напечатать буквы, которые дублируются в строке.
            Обратите внимание, что строка отсортирована, т.e. дубли идут друг за другом.
            В итоге в консоль должен быть выведен результат программы: "acdgijk"
            - Критерии оценки
                – Данные в строке отсортированы корректно
                –При изменении содержания строки результат программы выполняется.
                – Результат программы выведен в консоль согласно условиям задачи.
        Напишите метод, который в виде параметра принимает отсортированную строку.
        Например, aabccddefgghiijjkk.
        С помощью цикла проверьте, что в строке нет дублей, и выведите в консоль сообщение об этом.
        Если дубль найден, нужно прервать поиск по остальным символам и вывести сообщение о присутствии дубля, причем с указанием,
        какой именно символ задублирован. Затем сразу же прервать выполнение метода.
        Сам метод ничего возвращать не должен (void).
    * */
        private static void task5 (){
        String text = "aabccddefgghiijjkk";
        textParser(text, false); //bool true- вывести список, bool false  остановить программу
        }

    private static void textParser (String text, boolean bool){
        StringBuilder textNew = new StringBuilder();
        for (int i = 1; i < text.length(); i++) {
            if(!contains(textNew, Character.toString(text.charAt(i))) && text.charAt(i) == text.charAt(i-1)) {
                textNew.append(text.charAt(i));
                if (!bool){
                    System.out.println("Присутствует дубль " + text.charAt(i));
                    break;
                }
            }


        }
        System.out.println(textNew);
    }

    private static boolean contains(StringBuilder sb, String findString){
        return sb.indexOf(findString) > -1;
    }

    /*
    Cнова вспоминаем домашнее задание по массивам. В нем была задача, которая требовала высчитать среднюю выплату за день.
    Был дан сгенерированный массив из 30 значений от 100 до 200 тысяч, для его генерации допускается использовать метод из прошлого домашнего задания.
    - Текст прошлого задания
        Нам нужно понять, какую в среднем сумму наша компания тратила в течение данных 30 дней.
        Нужно написать программу, которая посчитает среднее значение трат за месяц (то есть сумму всех трат за месяц поделить на количество дней),
    и вывести в консоль результат в формате: «Средняя сумма трат за месяц составила … рублей».
        **Важно помнить:** подсчет среднего значения может иметь остаток (то есть быть не целым, а дробным числом).
    Нужно сгенерировать массив, подать его в наш метод, а внутри метода подсчитать сумму элементов и вычислить среднее значение,
    которое нужно вернуть из метода в виде результата.
    Сложность в том, что метод нужно не просто написать, но еще и декомпозировать.
    То есть для работы этого метода нужно будет создать еще методы (1 или более),
    которые его будут обслуживать и вычислять промежуточные результаты. Среднее значение нужно вычислять в дробном виде, так как результат должен быть точным.
    * */

    private static void task6(){
        var days = 5;
        int[] arr = generateRandomArray(days);
        System.out.println(Arrays.toString(arr));
        var sum = sumInMonth(arr);
        var avgSum = avgSum(sum, days);
        var max = maxSum(arr);
        var min = minSum(arr);

        System.out.println("Сумма трат за месяц составила " + sum + " рублей "
                            +"\nСредняя сумма трат за месяц составила "+ avgSum+" рублей "
                            +"\nМинимальная сумма трат за день составила " + min + " рублей "
                            +"\nМаксимальная сумма трат за день составила "+ max + " рублей");

    }
    private static int maxSum (int[] arr){
        int max = 0;
        for (int i = 0; i < arr.length; i++) {
            if (max < arr[i]) {
                max = arr[i];
            }
        }
        return max;
    }
    private static int minSum (int[] arr){
        int min = 0;
        for (int i = 0; i < arr.length; i++) {
            if (min > arr[i] || min == 0) {
                min = arr[i];
            }
        }
        return min;
    }

    private static float avgSum (int sum, int days){
        return (float) sum/days;
    }

    private static int sumInMonth (int[] arr){
        int sum = 0;
        for (int element : arr) {
            sum += element;
        }

        return sum;
    }

    private static int[] generateRandomArray(int numberOfDays) {
        java.util.Random random = new java.util.Random();
        int[] arr = new int[numberOfDays];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100_000) + 100_000;
        }
        return arr;
    }

}