import java.time.LocalDate;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        System.out.println("Задание 1");
        task1();
        System.out.println("Задание 2");
        task2();
        System.out.println("Задание 3");
        task3();
        System.out.println("Задание 4");
        task4();
    }


    /*1
    Реализуйте метод, который получает в качестве параметра год, а затем проверяет, является ли он високосным, и выводит результат в консоль.
    Эту проверку вы уже реализовывали в задании по условным операторам.
    Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
    Результат программы выведите в консоль. Если год високосный,
     то должно быть выведено “*номер года —* високосный год”.
    Если год не високосный, то, соответственно: “*номер года —* не **високосный год”.
    Подсказку с выполнением задания вы можете найти в шпаргалке урока.*
     */

    private static void task1(){
        leapYear(2024);
    }
    private static void leapYear( int year){
        if (year % 400 == 0) {
            System.out.println(year +" високосный год");
        } else if (year % 4 == 0 && year % 100 != 0) {
            System.out.println(year +" високосный год");
        }else {
            System.out.println(year +" невисокосный год");
        }
    }

    /*2
     Вспомним задание 2 по условным операторам, где нам необходимо было предложить пользователю облегченную версию приложения.
    - Текст прошлого задания
        К нам пришли коллеги и сообщили, что нам нужно знать не только операционную систему телефона, но и год его создания: от этого зависит,
        подойдет ли приложение для телефона или оно просто не установится.
        Если телефон произведен с 2015 по нынешний год, то приложение будет работать корректно.
        Если телефон произведен ранее 2015 года, то клиенту нужно посоветовать установить облегченную версию приложения.
        Ваша задача: написать программу, которая выдает соответствующее сообщение клиенту при наличии двух условий —
        операционной системы телефона (iOS или Android) и года производства.
        Если год выпуска ранее 2015 года, то к сообщению об установке нужно добавить информацию об облегченной версии.
        Например, для iOS оно будет звучать так:
        «Установите облегченную версию приложения для iOS по ссылке».
        А для Android так:
        «Установите облегченную версию приложения для Android по ссылке».
        При этом для пользователей с телефоном с 2015 года выпуска нужно вывести обычное предложение об установке приложения.
        Для обозначения года создания используйте переменную clientDeviceYear, где необходимо указать 2015 год.
        **Важно**: вложенность больше двух этажей не допускается (условный оператор внутри условного оператора).
    Напишите метод, куда подаются два параметра: тип операционной системы (ОС) ( 0 — iOS или 1 — Android) и год выпуска устройства.
    Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
    Текущий год можно получить таким способом:
    ```java
    int currentYear = LocalDate.now().getYear();
    ```
    Или самим задать значение вручную, введя в переменную числовое значение.
    В результате программа должна выводить в консоль в зависимости от исходных данных,
    какую версию приложения (обычную или lite) и для какой ОС (Android или iOS) нужно установить пользователю.
    * */

    //int currentYear = LocalDate.now().getYear();

    private static void task2 () {
        int clientDeviceYear = 2015;
        byte clientOS = 1;
        typeOs(clientDeviceYear, clientOS);

    }

    private static void typeOs (int year, byte os){
        int currentYear = LocalDate.now().getYear();
        if (year < currentYear && os == 0) {
            System.out.println("Установите облегченную версию приложения для iOS по ссылке");
        } else if (year < currentYear && os == 1) {
            System.out.println("Установите облегченную версию приложения для Android по ссылке");
        } else {
            System.out.println("Приложение установлено");
        }
    }

    /*3
    Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
    - Текст прошлого задания
    Вернемся к делам банковским. У нас хороший банк, поэтому для наших клиентов мы организуем доставку банковских карт на дом с четкой датой доставки.
    Чтобы известить клиента о том, когда будет доставлена его карта, нам нужно знать расстояние от нашего офиса до адреса доставки.
    Правила доставки такие:
    Доставка в пределах 20 км занимает сутки.
    Доставка в пределах от 20 км до 60 км добавляет еще один день доставки.
    Доставка в пределах 60 км до 100 км добавляет еще одни сутки.
    То есть с каждым следующим интервалом доставки срок увеличивается на 1 день.
    Напишите программу, которая выдает сообщение в консоль:
    "Потребуется дней: " + срок доставки
    Объявите целочисленную переменную deliveryDistance = 95, которая содержит дистанцию до клиента
    Наша задача — доработать код, а именно написать метод, который на вход принимает дистанцию и возвращает итоговое количество дней доставки.
    * */

    private static void task3() {
        int deliveryDistance = 101;
        if (deliveryDistanceCheck(deliveryDistance) == 0){
            System.out.println("Заберите карту в ближайшем отделении банка");
            return;
        }
        int day = speedDelivery(deliveryDistance);
        System.out.println("Потребуется дней: "+ day);
    }

    private static int  speedDelivery (int deliveryDistance){
        int day =1;
        if (deliveryDistance > 20 && deliveryDistance <= 60){
            day += 1;
        }else if (deliveryDistance > 60 && deliveryDistance <= 100){
            day += 2;
        }
        return day;
    }

    private static int deliveryDistanceCheck(int distance){
        byte ok = 1;
        if (distance > 100) {ok = 0;}
        return ok;
    }

    /*4
    Напишите метод, который получает на вход массив и переставляет все его элементы в обратном порядке.
    Подобное задание вы решали в домашнем задании по массивам.
    - Текст прошлого задания
        Отойдем от подсчетов.
        В нашей бухгалтерской книге появился баг. Что-то пошло нет так, и Ф.И.О. сотрудников начали отображаться в обратную сторону. Т. е.
        вместо «Иванов Иван Иванович» мы имеем «чивонавИ навИ вонавИ».
        Данные с именами сотрудников хранятся в виде массива символов (char[]).
        Напишите код, который в случае такого бага будет выводить Ф. И. О. сотрудников в корректном виде. В качестве данных для массива используйте:
        char[] reverseFullName = { 'n', 'a', 'v', 'I', ' ', 'v', 'o', 'n', 'a', 'v', 'I'};
        В результате в консоль должно быть выведено "Ivanov Ivan".
        **Важно**: не используйте дополнительные массивы для решения этой задачи. Необходимо корректно пройти по массиву циклом и
        распечатать его элементы в правильном порядке
    В метод приходит массив, допустим:
    {3, 2, 1, 6, 5}.
    Нужно без вспомогательного массива переместить элементы так, чтобы поданный массив стал: {5, 6, 1, 2, 3}.
    Рекомендуем написать этот метод без возвращаемого значения. Вы будете приятно удивлены, что даже если мы не вернем массив,
    первоначальный массив изменится, когда мы будем модернизировать пришедший в виде параметра массив внутри метода.
    Причину такого поведения ссылочных типов (объектов) вы узнаете на следующем уроке или на QA-вебинаре.
    * */

    private static void task4 (){
        Object[] reverseFullName = { 'n', 'a', 'v', 'I', ' ', 'v', 'o', 'n', 'a', 'v', 'I'};
        nameCorrect(reverseFullName);
        System.out.println();
        Object[] data = {3, 2, 1, 6, 5};
        nameCorrect(data);
        System.out.println();
        arrayReplace(data);
        arrayReplace(reverseFullName);
    }

    private static void nameCorrect (Object[] arr) {
        for (int i = arr.length - 1; i >= 0; i--) {
            System.out.print(arr[i]);
        }
    }

    private static void arrayReplace (Object[] arr){
        int j = arr.length-1;
        for (int i = 0; i < arr.length/2; i++) {
            Object t = arr[i];
            arr[i] = arr[j-i];
            arr[j-i] = t;
        }
        System.out.println(Arrays.toString(arr));
    }


}